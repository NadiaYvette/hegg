Consider rolling my own hash functions because if I can uniquely identify the
constructor, since the map only consists of nodes, only need to make a
composite hash function with the unique identifier and the e-class ids. better
yet, I should do that on my side with generics. I can also do a O(1) length
with generics

better substitutions

~~findRepr with Virtual Memory paging like structure mapping ints to arrays where the items are (higher bits map to arrays, lower bits map to index in array)~~

FindRepr is almost always at depth0, meaning the issue is with 1time in lookup times, the number of times findRepr is called, and the constant factors
Memoization for Database
Memoization for ReprUnionFind
HashSet for ENodes
Careful with collisions regarding the carefree use of intmaps+hashing...
Consider using unordered containers altogether
Drop Hashable dependency by vendoring generic hash? Can we use Uniques in GHC if we vendor this?
Memo data structure is not good enough, maybe UniqMap
UniqMap
Memoization in find / canonicalize
Memoizatiion?
Analysis should take a type level Symbol to identify it, so we can have multiple analysis for the same language
Test that e-classes are never empty
Should all nodes in maps be canonical? Or better to keep finding them when need to use? Must check which is more common, probably checking is done way less so it's better to just find them when needed
Continuous database carried in the e-graph, also updated when rebuilding... (how?)
If already reached optimal solution (cost == 1) can stop searching?
Delete represented nodes after canonicalizing the id
How to make Fix compatible with Data.Fix
